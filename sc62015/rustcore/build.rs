use std::env;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;

use serde::Deserialize;

#[derive(Deserialize)]
struct MetadataEnvelope {
    version: u32,
    instructions: Vec<InstructionRecord>,
}

#[derive(Deserialize)]
struct InstructionRecord {
    opcode: u32,
    mnemonic: String,
    length: u32,
    asm: String,
    il: Vec<String>,
}

fn main() {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("manifest dir"));
    let script_path = manifest_dir.join("../tools/generate_opcode_metadata.py");
    println!("cargo:rerun-if-changed={}", script_path.display());
    println!(
        "cargo:rerun-if-changed={}",
        manifest_dir
            .join("../pysc62015/instr/opcode_table.py")
            .display()
    );

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR missing"));
    let dest_path = out_dir.join("opcode_table.rs");

    match run_generator(&script_path) {
        Ok(envelope) => {
            if envelope.version != 1 {
                eprintln!(
                    "Unexpected opcode metadata version {} (expected 1); using fallback table",
                    envelope.version
                );
                write_fallback(&dest_path).expect("failed to write fallback table");
            } else {
                write_table(&dest_path, &envelope.instructions)
                    .expect("failed to write opcode table");
            }
        }
        Err(err) => {
            eprintln!("warning: opcode metadata generation failed: {err}");
            write_fallback(&dest_path).expect("failed to write fallback table");
        }
    }
}

fn run_generator(script_path: &Path) -> Result<MetadataEnvelope, String> {
    if !script_path.exists() {
        return Err(format!(
            "metadata generator not found at {}",
            script_path.display()
        ));
    }

    let python = find_python().ok_or_else(|| "python3/python not found in PATH".to_string())?;
    let output = Command::new(python)
        .arg(script_path)
        .env("FORCE_BINJA_MOCK", "1")
        .output()
        .map_err(|err| format!("failed to spawn generator: {err}"))?;

    if !output.status.success() {
        return Err(format!(
            "generator exited with {}: {}",
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ));
    }

    serde_json::from_slice(&output.stdout)
        .map_err(|err| format!("failed to parse generator output: {err}"))
}

fn find_python() -> Option<&'static str> {
    for candidate in ["python3", "python"] {
        if Command::new(candidate).arg("--version").output().is_ok() {
            return Some(candidate);
        }
    }
    None
}

fn write_table(path: &Path, instructions: &[InstructionRecord]) -> std::io::Result<()> {
    let mut file = File::create(path)?;
    writeln!(
        file,
        "// @generated by build.rs â€” do not edit by hand\n\
         #[derive(Debug)]\n\
         pub struct OpcodeMetadata {{\n    pub opcode: u8,\n    pub mnemonic: &'static str,\n    pub length: u8,\n    pub asm: &'static str,\n    pub il: &'static [&'static str],\n}}\n"
    )?;
    writeln!(file, "pub static OPCODES: &[OpcodeMetadata] = &[")?;

    let mut sorted: Vec<&InstructionRecord> = instructions.iter().collect();
    sorted.sort_by_key(|record| record.opcode);

    for record in sorted {
        let opcode = (record.opcode & 0xFF) as u8;
        let mnemonic = serde_json::to_string(&record.mnemonic).unwrap();
        let asm = serde_json::to_string(&record.asm).unwrap();
        let length = (record.length.min(0xFF)) as u8;
        let il_literal = if record.il.is_empty() {
            String::from("&[]")
        } else {
            let entries: Vec<String> = record
                .il
                .iter()
                .map(|line| serde_json::to_string(line).unwrap())
                .collect();
            format!("&[{}]", entries.join(", "))
        };

        writeln!(
            file,
            "    OpcodeMetadata {{ opcode: 0x{opcode:02X}, mnemonic: {mnemonic}, length: {length}, asm: {asm}, il: {il_literal} }},"
        )?;
    }

    writeln!(file, "];")?;
    Ok(())
}

fn write_fallback(path: &Path) -> std::io::Result<()> {
    let mut file = File::create(path)?;
    writeln!(
        file,
        "// @generated fallback\n\
         #[derive(Debug)]\n\
         pub struct OpcodeMetadata {{\n    pub opcode: u8,\n    pub mnemonic: &'static str,\n    pub length: u8,\n    pub asm: &'static str,\n    pub il: &'static [&'static str],\n}}\n\
         pub static OPCODES: &[OpcodeMetadata] = &[];"
    )?;
    Ok(())
}
