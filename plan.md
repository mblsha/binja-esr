- Findings

  - sc62015/core/src/perfetto.rs:51-118 - Perfetto register annotations don’t match Python casing/keys. Rust emits reg_BA/reg_A/reg_B (and uppercased BA) while Python _trace_perfetto writes reg_ba (lowercase) and no split A/B. The compare script treats annotation keys literally, so traces will diverge on every instruction.
  - sc62015/core/src/llama/eval.rs:19-21 - Perfetto counters (PERF_INSTR_COUNTER, PERF_CURRENT_PC, PERF_CURRENT_OP) are static and never reset. After a snapshot reload or a new run, op_index keeps incrementing from the previous session, unlike Python which resets _trace_instr_count per emulator/trace. Perfetto parity will drift immediately across runs.
  - sc62015/rustcore/src/lib.rs:301-332 & :242 - LlamaCpu’s timer path never advances cycles (it’s initialized to 0 and never incremented), yet tick_timers feeds that constant into TimerContext. MTI/STI/IRQ mirrors therefore never fire in the PyO3 backend, while Python’s _tick_timers (pce500/emulator.py:2345-2370) advances a scheduler on every cycle. Timer IRQs, KEYI cadence, and perfetto IRQ traces will never appear on Rust.
  - sc62015/core/src/timer.rs:133-185 & sc62015/rustcore/src/lib.rs:301-332 - Even if timers fired, the Rust timer path only sets MTI/STI bits; it never runs KeyboardMatrix.scan_tick or asserts KEYI on MTI the way Python does in _tick_timers (pce500/emulator.py:2345-2370). Timer-driven keyboard repeats/KEYI IRQs will be missing unless some other ad-hoc caller manually scans the keyboard.
  - sc62015/core/src/llama/state.rs:152-179 - reset clears regs and call_depth but leaves call_sub_level untouched. Python resets call depth/sub-level on power-on; after a reset/snapshot load the Rust call_sub_level can leak the old value into snapshots/perfetto traces.
  - sc62015/core/src/llama/eval.rs:214-247 vs sc62015/pysc62015/instr/instructions.py:1113-1125 - Stack pushes are little-endian in push_stack (low byte first), but the Python IR spec/comment says interrupt entry pushes PC high byte first then low. RET/RETI/IR stack frames are at risk of reversed byte order, which would throw off returns and parity traces.
