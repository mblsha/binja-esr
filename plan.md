Resolved
- sc62015/core/src/lib.rs: RETI fallback clearing, pending source prioritization (KEY/ONK), pending/perfetto diagnostics, and KEY overrides are aligned with Python; requires_python paths no longer panic and fall back like Python.
- sc62015/core/src/perfetto.rs: record_irq_check accepts Python parity fields; added CPU/Memory track aliases and optional wall-clock timestamps via PERFETTO_WALL_CLOCK for Python trace parity.
- sc62015/rustcore/src/lib.rs: tick_timers respects kb_irq_enabled before asserting KEYI.
- sc62015/core/src/llama/eval.rs & perfetto.rs: Prefixed instructions now annotate PC with the post-PRE value to match Python trace comparisons.
- sc62015/core/src/lib.rs & lcd.rs: IMEM 0x00–0x0F routes to the LCD controller overlay for parity with Python’s internal remap.
- sc62015/core/src/lib.rs: WAIT no longer spins timers and advances one cycle, matching Python fast-path semantics; regression test added.
- sc62015/core/src/lib.rs: RuntimeBus requires_python accesses now fall back instead of panicking, matching Python tolerance.

Tests/Checks
- cargo test --quiet (sc62015/core)
- uv run pytest sc62015/pysc62015 -q
- uv run pytest pce500/tests -q
- uv run pytest web/tests -q
- Perfetto comparisons: sweep_trace_python.trace vs sweep_trace_llama.trace; long_trace_python.trace vs long_trace_llama.trace; trace_ref_python.trace vs trace_ref_llama.trace; trace_latest_python.trace vs trace_latest_llama.trace (no divergence)
- uv run python scripts/check_rust_py_parity_annotations.py
- uv run python scripts/check_llama_opcodes.py
- uv run python scripts/check_llama_pre_tables.py

Findings
- Perfetto clock source drifts from Python: sc62015/core/src/perfetto.rs:61-107 defaults to wall-clock timestamps, so traces depend on host scheduling instead of instruction/cycle ticks. Parity tools that diff Rust vs Python traces will see jittered timestamps even when op_index order matches.
- Perfetto context for off-core events is often stale. Host/timer/keyboard writes fall back to the last recorded op_index/PC when no executor context is active: memory.rs:248-277 (apply_host_write_with_cycle), timer.rs:350-452 (KeyIRQ/KeyScan events) and timer.rs:464-495 (TimerFired) all stamp events with perfetto_last_* instead of the actual cycle/op that caused them (e.g., during HALT/WAIT ticks). This diverges from the Python tracer, which aligns these events to the driving cycle/op.
- WAIT accuracy gap: the executor simply clears I/C/Z and advances PC (llama/eval.rs:1767-1777) and the runtime suppresses all timer ticks when opcode==WAIT (core/src/lib.rs:955-979), always incrementing cycles by 1. If Python/hardware treats WAIT as an idle loop that burns I cycles and lets timers/KEYI advance, Rust will under-run timers and produce different perfetto timing.
- TCL is effectively a no-op: it shares the IR path but when entry.kind == Tcl the code only bumps PC (llama/eval.rs:2185-2224), with no stack activity, IMR/ISR masking, or perfetto IRQ markers. Python’s TCL intrinsic (if modeled as an interrupt/trap) will diverge.
- IRQ delivery ignores the IMR master when KEYI/ONKI bits are set: core/src/lib.rs:1217-1288 treats keyboard/on-key as level-triggered and enables delivery even if IMR bit 7 is clear. If Python/hardware holds off IRQ entry until the master is set, Rust will deliver spurious IRQs (and emit IRQ_Enter/Delivered perfetto events) while the CPU should stay masked.
- LCD address window is truncated on the low mirror: lcd.rs:60-96 rejects accesses above 0x200F even though handles() reports the whole 0x2000..0x200F/0xA000..0xAFFF range. Any firmware writes to the broader 0x2000 window (common HD61202 aliasing) will be dropped here but accepted by Python’s controller wrapper.
- IMR read tracing can silently disappear: memory.rs:342-387 uses try_lock when emitting perfetto IMR_Read events; under contention those reads are ignored. Python emits every IMR read, so counts and counters (IMR_ReadZero/NonZero) will diverge.
- WAIT timing is off: the run loop treats WAIT as a single-cycle no-op and skips timer ticks (sc62015/core/src/lib.rs:967-977), even though it captures the pre-clear I value at lines 934-936. Python _simulate_wait walks every WAIT iteration, bumping cycle_count and calling _tick_timers each time (pce500/emulator.py:1064-1155, 1808-1818). Result: MTI/STI/KEYI never fire during WAIT on Rust, cycle_count in snapshots drifts, and Perfetto misses the TimerFired/KeyScan events that Python produces during the simulated idle loop.
- KEYI latch gets dropped when KEY IRQs are masked: refresh_key_irq_latch immediately clears key_irq_latched and won’t reassert KEYI if kb_irq_enabled is false (sc62015/core/src/lib.rs:505-519). Python keeps _key_irq_latched and reasserts KEYI even when timers/IRQs are otherwise idle to preserve pending keyboard events (pce500/emulator.py:630-648 and _key_irq_latched usage). Firmware that disables KEY interrupts with FIFO data pending will see the IRQ vanish on Rust but retrigger on Python, and the corresponding Perfetto KeyIRQ/KeyScan markers will be missing.
- Snapshot timer scaling parity gap: TimerContext::apply_snapshot_info ignores allow_scale/LLAMA_TIMER_SCALE and restores MTI/STI periods verbatim (sc62015/core/src/timer.rs:70-122). Python’s load_snapshot applies LLAMA_TIMER_SCALE for the LLAMA backend and rebases the scheduler with scaled periods (pce500/emulator.py:1635-1675). With the env var set, Rust timers stay unscaled, so interrupt cadence and Perfetto timing after restore diverge from Python.
- sc62015/core/src/timer.rs:124-133 saves irq_bit_watch as {IMR: {}, ISR: {}} when no history is present. The Python side initializes per-bit {"set":[],"clear":[]} buckets and _record_irq_bit_watch indexes them directly. A Rust snapshot loaded in Python will drop the per-bit structure (and can raise on the first bit-watch update), and even Rust↔Python comparisons will report mismatched metadata because the set/clear histories are missing.
- sc62015/core/src/lib.rs:1390-1402 (IRQ delivery) pushes the current PC and the ISR bitmask onto timer.interrupt_stack, and RETI clearing falls back to interrupt_stack.last() when irq_source is None (sc62015/core/src/lib.rs:1010-1014). Python snapshots store _interrupt_stack as interrupt flow IDs (see pce500/emulator.py:1478,2045-2063). Loading a Python snapshot into Rust will treat those IDs as ISR masks, so RETI can clear the wrong bit or none at all, and the saved stack contents diverge from Python’s tracing semantics.
- sc62015/core/src/timer.rs:274-309 updates irq_bit_watch only for timer fires. KEYI/ONKI assertions from keyboard scans (tick_timers_with_keyboard) or ON-key handling never call record_bit_watch, while Python’s _set_isr_bits path is used for both timers and keyboard and records ISR/IMR transitions. Snapshot metadata and any bit-watch-driven diagnostics will diverge whenever interrupts are keyboard-driven.
- Perfetto instrumentation drops events under contention: IMEM writes/reads log via PERFETTO_TRACER.try_lock() (sc62015/core/src/memory.rs:396-420,437-447), so concurrent logging can silently skip IMR/ISR/KIO annotations. The Python tracer uses a reentrant lock and doesn’t drop these, so traces can diverge in high-traffic paths (keyboard polling, IRQ toggles).
- sc62015/core/src/llama/eval.rs: WAIT fast-path only clears I/C/Z and advances PC; it never calls LlamaBus::wait_cycles or advances timers/keyboard on its own. The CoreRuntime wrapper simulates idle cycles, but any standalone executor client (contract harness, rustcore bus, or the pce500 CLI if it ever bypasses CoreRuntime) will under-run timers compared to Python’s _simulate_wait loop.
- sc62015/core/src/lib.rs IRQ delivery path (deliver_pending_irq around the IRQ_Enter flow) pushes IMR/F/PC and sets timer.in_interrupt, but it never bumps state.call_depth. Python increments call depth on CALL/IR opcodes, so perfetto call_depth counters and snapshot metadata will under-report interrupt nesting for hardware-delivered IRQs (vs. IR intrinsic), which can skew compare_perfetto_traces and snapshots restored into Python.
- sc62015/core/src/memory.rs + lib.rs RuntimeBus: IMEM LCD overlay reads/writes (0x00–0x0F routed to LcdController) bypass MemoryImage’s read/write counters. Python’s memory layer counts those accesses, so memory_reads/memory_writes in snapshots and perfetto counters can drift whenever the firmware touches the LCD via the IMEM mirror.
- Perfetto context for off-core events still falls back to the last recorded op_index/PC when no cycle is supplied (e.g., MemoryImage::apply_host_write_with_cycle without a cycle, TimerContext::emit_irq_trace when no perfetto context is active). Python’s tracer timestamps these against cycle_count, so HALT/WAIT-side host writes or timer firings can land on stale PCs in Rust traces even when ordering matches.
