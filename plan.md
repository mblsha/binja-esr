- call_sub_level never decrements on returns in Rust (sc62015/core/src/llama/state.rs:158-169), but Python adjusts it with CALL_STACK_EFFECTS (e.g., RET/RETF/RETI apply -1; sc62015/pysc62015/emulator.py:43-50,534-542). This makes Rust call-depth metadata and snapshots diverge (call_sub_level will monotonically grow).
- Instruction Perfetto events are emitted twice per opcode in the LLAMA runner: once from trace_instr inside the executor (sc62015/core/src/llama/eval.rs:367-409) and again after execution in the standalone runner (sc62015/core/src/bin/pce500.rs:1388-1427). Python only records a single InstructionTrace event per instruction (pce500/emulator.py:1860-1905), so traces will never align and compare_perfetto_traces.py will flag mismatches.
- E-port inputs are hard-stubbed to zero in Rust keyboard handling (KeyboardMatrix::handle_read/handle_write, sc62015/core/src/keyboard.rs:481-518), while Python’s keyboard handler surfaces ON/ONK/PEI input state (pce500/emulator.py:2929-3018). As a result, ON/ONK-driven IRQs and input sampling can never occur in the Rust path, diverging from Python behaviour.
- IMEM LCD/keyboard overlays are ignored in Rust. MemoryImage::requires_python exempts 0x00–0x0F but the Rust bus never routes those overlay addresses to the LCD controller, so writes land in plain RAM only. Python installs overlay handlers via memory.set_keyboard_handler(..., enable_overlay=True) and forwards those accesses to the LCD/keyboard devices (pce500/emulator.py:264-275). Any firmware path that relies on the IMEM overlay will diverge.
- Snapshots produced by the Rust core omit keyboard state/metrics and other peripheral fields (sc62015/core/src/lib.rs:343-357 always passes None for keyboard/LCD, and snapshot.rs only saves raw memory/registers). Python snapshots persist keyboard state and metrics (pce500/emulator.py:1400-1512), so restoring a Rust snapshot will lose KOL/KOH/KIL, FIFO, and IRQ latch context, breaking parity for resume and trace comparison.
